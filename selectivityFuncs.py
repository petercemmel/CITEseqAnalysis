"""
Functions used in binding and selectivity analysis
"""
import string
from .imports import importCITE, importReceptors
from .MBmodel import cytBindingModel_CITEseq, cytBindingModel_bispecCITEseq, cytBindingModel_bispecOpt, cytBindingModel_basicSelec
from os.path import dirname, join
from scipy.optimize import minimize, Bounds
import pandas as pd
import numpy as np

path_here = dirname(dirname(__file__))


def getSampleAbundances(epitopes: list, cellList: list):
    """Given list of epitopes and cell types, returns a dataframe containing abundance data on a single cell level
    Args:
        epitopes: list of epitopes for which you want abundance values
        cellList: list of cell types for which you want epitope abundance

    Returns:
        epitopesDF: dataframe containing single cell abundances of epitopes(rows) for each cell type(columns).
        Each frame contains a list of size corresponding to representative sample of cell type
    """
    # This dataframe will later be filled with our epitope abundance by cells
    receptors = {'Epitope': epitopes}
    epitopesDF = pd.DataFrame(receptors)

    # Import CITE data
    CITE_DF = importCITE()

    # Get conv factors, average them to use on epitopes with unlisted conv facts
    convFact = convFactCalc()
    meanConv = convFact.Weight.mean()

    # Sample sizes generated corresponding to cell list using mean values
    sampleSizes = []
    for cellType in cellList:
        cellSample = []
        for i in np.arange(10):  # Averaging results of 10
            sampleDF = CITE_DF.sample(1000)  # Of 1000 cells in the sample...
            sampleSize = int(len(sampleDF.loc[sampleDF["CellType2"] == cellType]))  # ...How many are this cell type
            cellSample.append(sampleSize)  # Sample size is equivalent to represented cell count out of 1000 cells
        meanSize = np.mean(cellSample)
        sampleSizes.append(int(meanSize))

    # For each  cellType in list
    for i, cellType in enumerate(cellList):
        # Generate sample size
        sampleSize = sampleSizes[i]
        # Create data frame of this size at random selection
        cellDF = CITE_DF.loc[CITE_DF["CellType2"] == cellType].sample(sampleSize)

        cellType_abdundances = []
        # For each epitope (being done on per cell basis)
        for e in epitopesDF.Epitope:
            # calculate abundance based on converstion factor
            if e == 'CD25':
                convFact = 77.136987  # The values are from convFactCalc
            elif e == 'CD122':
                convFact = 332.680090
            elif e == "CD127":
                convFact = 594.379215
            else:
                convFact = meanConv

            # Calculating abundance from cite data
            citeVal = cellDF[e].to_numpy()  # Getting CITE signals for each cell
            abundance = citeVal * convFact  # (CITE signal * conversion factor) = abundance
            cellType_abdundances.append(abundance)  # Append abundances for individual cells into one list
            # add column with this name to epitopesDF and abundances list

        epitopesDF[cellType] = cellType_abdundances  # This list will be located at Epitope x Cell Type in the DF

    return epitopesDF


def getSignaling(betaAffs: np.array, targCell: string, offTCells: list, epitopesDF: pd.DataFrame):
    """Returns total signaling summed over single cells for given parameters, can be adjusted for various purposes
    Args:
        betaAffs: 1D numpy array of beta receptor affinities over which to analyze signaling
        targCell: string Cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        epitopesDF: contains info on epitope abundance by cell type (generated by getSampleAbundance())

    Returns:
        target_sigs: List of total on target signal (sum of single cells in sample). Each item in list corresponds
        to different modeling paradigm (Wild type signaler, mutein, different valency, etc.)
        offTarg_sigs:  List of total off target signal
    """

    target_sigs = np.zeros((8, betaAffs.size))  # 8 is used here because we are comparing 8 total signal types
    offTarg_sigs = np.zeros((8, betaAffs.size))

    # 0-2 IL2 WT
    # 3-5 R38Q
    # 6-7 Live/Dead
    muts = ['IL2', 'R38Q/H16N']
    vals = [1, 2, 4]

    for i, aff in enumerate(betaAffs):
        for j, mut in enumerate(muts):
            for k, val in enumerate(vals):
                n = (3 * j) + k
                target_sig, offTarg_sig = bindingCalc(epitopesDF, targCell, offTCells, aff, val, mut)
                target_sigs[n, i] = target_sig
                offTarg_sigs[n, i] = offTarg_sig

        target_sig_bi, offTarg_sig_bi = bindingCalc(epitopesDF, targCell, offTCells, aff, 1, 'R38Q/H16N', bispec=True, epitope='CD25')
        target_sigs[6, i] = target_sig_bi
        offTarg_sigs[6, i] = offTarg_sig_bi

        target_sig_bi, offTarg_sig_bi = bindingCalc(epitopesDF, targCell, offTCells, aff, 2, 'R38Q/H16N', bispec=True, epitope='CD25')
        target_sigs[7, i] = target_sig_bi
        offTarg_sigs[7, i] = offTarg_sig_bi

    return target_sigs, offTarg_sigs


def bindingCalc(df: pd.DataFrame, targCell: string, offTCells: list, betaAffs: np.array, val: int, mut: string, bispec=False, epitope: string = None):
    """Calculates selectivity for no additional epitope
    Args:
        df: (epitopesDF) contains info on epitope abundance by cell type (generated by getSampleAbundance())
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        betaAffs: 1D numpy array of beta receptor affinities over which to analyze signaling
        val: desired valency of sigaling molecule
        mut: mutein signaling molecule name or wild type (dataset specific)
        bispec: if false, runs standard model...if true, runs bispecific signaling model
        epitope: REQUIRED if bispec=True, additional epitope to be targeted

    Returns:
        targetBound: total sum of signal generated by on target single cells as calculated by model
        offTargetBound: total sum of signal generated by off target single cells as calculated by model
    """
    targetBound = 0
    offTargetBound = 0

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    cd122DF = df.loc[(df.Epitope == 'CD122')]

    if(bispec):
        epitopeDF = df.loc[(df.Epitope == epitope)]

        for i, cd25Count in enumerate(cd25DF[targCell].item()):
            cd122Count = cd122DF[targCell].item()[i]
            epitopeCount = epitopeDF[targCell].item()[i]
            counts = [cd25Count, cd122Count, epitopeCount]
            targetBound += cytBindingModel_bispecCITEseq(counts, betaAffs, 9.0, val, mut)

        for cellT in offTCells:
            for i, cd25Count in enumerate(cd25DF[cellT].item()):
                cd122Count = cd122DF[cellT].item()[i]
                epitopeCount = epitopeDF[cellT].item()[i]
                counts = [cd25Count, cd122Count, epitopeCount]
                offTargetBound += cytBindingModel_bispecCITEseq(counts, betaAffs, 9.0, val, mut)

    else:
        for i, cd25Count in enumerate(cd25DF[targCell].item()):
            cd122Count = cd122DF[targCell].item()[i]
            counts = [cd25Count, cd122Count]
            targetBound += cytBindingModel_CITEseq(counts, betaAffs, val, mut)

        for cellT in offTCells:
            for i, cd25Count in enumerate(cd25DF[cellT].item()):
                cd122Count = cd122DF[cellT].item()[i]
                counts = [cd25Count, cd122Count]
                offTargetBound += cytBindingModel_CITEseq(counts, betaAffs, val, mut)

    return targetBound, offTargetBound


def minSelecFunc(x: float, df: pd.DataFrame, targCell: string, offTCells: list, epitope: string):
    """Serves as the function which will have its return value minimized to get optimal selectivity
    To be used in conjunction with optimizeDesign()
    Args:
        x: receptor affinity which is modulated in optimize design
        df: contains epitope abundance information by cell type
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        epitope: additional epitope to be targeted

    Return:
        selectivity: value will be minimized, defined as ratio of off target to on target signaling
    """
    targetBound = 0
    offTargetBound = 0

    recXaff = x

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    cd122DF = df.loc[(df.Epitope == 'CD122')]
    epitopeDF = df.loc[(df.Epitope == epitope)]

    for i, epCount in enumerate(epitopeDF[targCell].item()):
        cd25Count = cd25DF[targCell].item()[i]
        cd122Count = cd122DF[targCell].item()[i]
        counts = [cd25Count, cd122Count, epCount]
        targetBound += cytBindingModel_bispecOpt(counts, recXaff)
        

    for cellT in offTCells:
        for i, epCount in enumerate(epitopeDF[cellT].item()):
            cd25Count = cd25DF[cellT].item()[i]
            cd122Count = cd122DF[cellT].item()[i]
            counts = [cd25Count, cd122Count, epCount]

            offTargetBound += cytBindingModel_bispecOpt(counts, recXaff)

    selectivity = (offTargetBound) / (targetBound)
    return selectivity


def optimizeDesign(targCell: string, offTcells: list, selectedDF: pd.DataFrame, epitope: string):
    """ A general purpose optimizer used to minimize selectivity output by varying affinity parameter.
    Args:
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        selectedDf: contains epitope abundance information by cell type
        epitope: additional epitope to be targeted

    Return:
        optSelectivity: optimized selectivity value. Can also be modified to return optimized affinity parameter.
     """
    if targCell == "NK":
        X0 = [6.0, 8]
    else:
        X0 = [9.0]

    optBnds = Bounds(np.full_like(X0, 6.0), np.full_like(X0, 9.0))
    print('Optimize')
    optimized = minimize(minSelecFunc, X0, bounds=optBnds, args=(selectedDF, targCell, offTcells, epitope), jac="3-point")
    print('Done')
    optSelectivity = optimized.fun
    print(optSelectivity)

    return optSelectivity


def selecCalc(df: pd.DataFrame, targCell: string, offTCells: list):
    """Calculates selectivity for no additional epitope
    Args:
        targCell: string cell type which is target and signaling is desired (basis of selectivity)
        offTCells: list of strings of cell types for which signaling is undesired
        df: contains epitope abundance information by cell type(importantly including cd25 anf cd122 here)
    Returns:
        selectivity value of standard IL2 based on abundances
    """
    targetBound = 0
    offTargetBound = 0

    cd25DF = df.loc[(df.Epitope == 'CD25')]
    cd122DF = df.loc[(df.Epitope == 'CD122')]

    for i, cd25Count in enumerate(cd25DF[targCell].item()):
        cd122Count = cd122DF[targCell].item()[i]
        counts = [cd25Count, cd122Count]
        targetBound += cytBindingModel_basicSelec(counts)
    for cellT in offTCells:
        for i, cd25Count in enumerate(cd25DF[cellT].item()):
            cd122Count = cd122DF[cellT].item()[i]
            counts = [cd25Count, cd122Count]
            offTargetBound += cytBindingModel_basicSelec(counts)

    return (offTargetBound) / (targetBound)


cellDict = {"CD4 Naive": "Thelper",
            "CD4 CTL": "Thelper",
            "CD4 TCM": "Thelper",
            "CD4 TEM": "Thelper",
            "NK": "NK",
            "CD8 Naive": "CD8",
            "CD8 TCM": "CD8",
            "CD8 TEM": "CD8",
            "Treg": "Treg"}


markDict = {"CD25": "IL2Ra",
            "CD122": "IL2Rb",
            "CD127": "IL7Ra",
            "CD132": "gc"}


def convFactCalc():
    """Returns conversion factors by marker for converting CITEseq signal into abundance"""
    CITE_DF = importCITE()
    cellToI = ["CD4 TCM", "CD8 Naive", "NK", "CD8 TEM", "CD4 Naive", "CD4 CTL", "CD8 TCM", "Treg", "CD4 TEM"]
    markers = ["CD122", "CD127", "CD25"]
    markerDF = pd.DataFrame(columns=["Marker", "Cell Type", "Amount", "Number"])
    for marker in markers:
        for cell in cellToI:
            cellTDF = CITE_DF.loc[CITE_DF["CellType2"] == cell][marker]
            markerDF = markerDF.append(pd.DataFrame({"Marker": [marker], "Cell Type": cell, "Amount": cellTDF.mean(), "Number": cellTDF.size}))

    markerDF = markerDF.replace({"Marker": markDict, "Cell Type": cellDict})
    markerDFw = pd.DataFrame(columns=["Marker", "Cell Type", "Average"])
    for marker in markerDF.Marker.unique():
        for cell in markerDF["Cell Type"].unique():
            subDF = markerDF.loc[(markerDF["Cell Type"] == cell) & (markerDF["Marker"] == marker)]
            wAvg = np.sum(subDF.Amount.values * subDF.Number.values) / np.sum(subDF.Number.values)
            markerDFw = markerDFw.append(pd.DataFrame({"Marker": [marker], "Cell Type": cell, "Average": wAvg}))

    recDF = importReceptors()
    weightDF = pd.DataFrame(columns=["Receptor", "Weight"])

    for rec in markerDFw.Marker.unique():
        CITEval = np.array([])
        Quantval = np.array([])
        for cell in markerDF["Cell Type"].unique():
            CITEval = np.concatenate((CITEval, markerDFw.loc[(markerDFw["Cell Type"] == cell) & (markerDFw["Marker"] == rec)].Average.values))
            Quantval = np.concatenate((Quantval, recDF.loc[(recDF["Cell Type"] == cell) & (recDF["Receptor"] == rec)].Mean.values))
        weightDF = weightDF.append(pd.DataFrame({"Receptor": [rec], "Weight": np.linalg.lstsq(np.reshape(CITEval, (-1, 1)).astype(float), Quantval, rcond=None)[0]}))
    return weightDF
